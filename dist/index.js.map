{
  "version": 3,
  "sources": ["../src/index.ts", "../src/fetchModule.ts", "../src/instantiateFFTWModule.ts", "../src/FFTW.ts"],
  "sourcesContent": ["import instantiateFFTWModule from \"./instantiateFFTWModule\";\r\nimport FFTW from \"./FFTW\";\r\n\r\nexport * from \"./types\";\r\n\r\nexport {\r\n    instantiateFFTWModule,\r\n    FFTW\r\n}\r\n\r\nexport default {\r\n    instantiateFFTWModule,\r\n    FFTW\r\n}\r\n", "const global: Window & { fetchModuleCache?: Map<string, any>; module: any; exports: any } = globalThis as any;\n\nconst cache = global.fetchModuleCache || new Map();\n\nconst fetchModule = async (url: string) => {\n\tconst absoluteUrl = new URL(url, location.href).href;\n\tif (cache.has(absoluteUrl)) return cache.get(absoluteUrl);\n\tlet exported: any;\n\tconst toExport = {};\n\tglobal.exports = toExport;\n\tglobal.module = { exports: toExport };\n\tconst esm = await import(/* webpackIgnore: true */absoluteUrl);\n\tconst esmKeys = Object.keys(esm);\n\tif (esmKeys.length) exported = esm;\n\telse exported = global.module.exports;\n\tdelete global.exports;\n\tdelete global.module;\n\tcache.set(absoluteUrl, exported);\n\treturn exported;\n};\n\nif (!global.fetchModuleCache) global.fetchModuleCache = cache;\n\nexport default fetchModule;\n", "import fetchModule from \"./fetchModule\";\nimport type { FFTWModuleFactory } from \"./types\";\n\n/**\n * Load fftw-wasm files, than instantiate fftw\n * @param jsFile path to `libfftw3.js`\n * @param wasmFile path to `libfftw3.wasm`\n */\nconst instantiateFFTWModule = async (jsFile: string, wasmFile = jsFile.replace(/c?js$/, \"wasm\")) => {\n    let LibFFTW: FFTWModuleFactory;\n    try {\n        LibFFTW = require(jsFile);\n    } catch (error) {\n        LibFFTW = await fetchModule(jsFile);\n    }\n    const locateFile = (url: string, scriptDirectory: string) => ({\n        \"libfftw3.wasm\": wasmFile\n    }[url]) || scriptDirectory + url;\n    const libFaust = await LibFFTW({ locateFile });\n    return libFaust;\n};\n\nexport default instantiateFFTWModule;\n", "import type { FFT, FFTWModule } from \"./types\";\r\n\r\nconst FFTW_ESTIMATE = (1 << 6);\r\n\r\nconst FFTW_R2HC = 0;\r\nconst FFTW_HC2R = 1;\r\nconst FFTW_DHT = 2;\r\nconst FFTW_REDFT00 = 3;\r\nconst FFTW_REDFT10 = 5;\r\nconst FFTW_REDFT01 = 4;\r\nconst FFTW_REDFT11 = 6;\r\nconst FFTW_RODFT00 = 7;\r\nconst FFTW_RODFT10 = 9;\r\nconst FFTW_RODFT01 = 8;\r\nconst FFTW_RODFT11 = 10;\r\n\r\nconst FFTW_FORWARD = -1;\r\nconst FFTW_BACKWARD = 1;\r\n\r\nclass FFTW {\r\n    c2c: { FFT1D: new (size: number) => FFT; FFT2D: new (n0: number, n1: number) => FFT; };\r\n    r2c: { FFT1D: new (size: number) => FFT; };\r\n    r2r: { FFT1D: new (size: number) => FFT; DCT1D: new (size: number) => FFT; DST1D: new (size: number) => FFT; FFT2D: new (n0: number, n1: number) => FFT; DCT2D: new (n0: number, n1: number) => FFT; DST2D: new (n0: number, n1: number) => FFT; };\r\n    constructor(fftwModule: FFTWModule) {\r\n        const fftwf_plan_dft_r2c_1d = fftwModule.cwrap(\r\n            \"fftwf_plan_dft_r2c_1d\", \"number\", [\"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n\r\n        const fftwf_plan_dft_c2r_1d = fftwModule.cwrap(\r\n            \"fftwf_plan_dft_c2r_1d\", \"number\", [\"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n\r\n        // fftw_plan fftw_plan_r2r_1d(int n, double *in, double *out,\r\n        //                            fftw_r2r_kind kind, unsigned flags);\r\n        const fftwf_plan_r2r_1d = fftwModule.cwrap(\r\n            \"fftwf_plan_r2r_1d\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n\r\n        // fftw_plan fftw_plan_r2r_2d(int n0, int n1, double *in, double *out,\r\n        //                            fftw_r2r_kind kind0, fftw_r2r_kind kind1,\r\n        //                            unsigned flags);\r\n        const fftwf_plan_r2r_2d = fftwModule.cwrap(\r\n            \"fftwf_plan_r2r_2d\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n        // fftw_plan fftw_plan_dft_1d(int n, fftw_complex *in, fftw_complex *out,\r\n        //                            int sign, unsigned flags)\r\n        const fftwf_plan_dft_1d = fftwModule.cwrap(\r\n            \"fftwf_plan_dft_1d\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n\r\n        // fftw_plan fftw_plan_dft_2d(int n0, int n1,\r\n        //                            fftw_complex *in, fftw_complex *out,\r\n        //                            int sign, unsigned flags)\r\n        const fftwf_plan_dft_2d = fftwModule.cwrap(\r\n            \"fftwf_plan_dft_2d\", \"number\", [\"number\", \"number\", \"number\", \"number\", \"number\", \"number\"]\r\n        );\r\n\r\n        const fftwf_execute = fftwModule.cwrap(\r\n            \"fftwf_execute\", null, [\"number\"]\r\n        );\r\n\r\n        const fftwf_destroy_plan = fftwModule.cwrap(\r\n            \"fftwf_destroy_plan\", null, [\"number\"]\r\n        );\r\n\r\n        const fftwf_free = fftwModule.cwrap(\r\n            \"fftwf_free\", null, [\"number\"]\r\n        );\r\n\r\n        const fftwf_malloc = fftwModule.cwrap(\r\n            \"fftwf_malloc\", \"number\", [\"number\"]\r\n        );\r\n\r\n        class C2CFFT2D implements FFT {\r\n            n0: number;\r\n            n1: number;\r\n            size: number;\r\n            c0ptr: number;\r\n            c1ptr: number;\r\n            c0: Float32Array;\r\n            c1: Float32Array;\r\n            fplan: number;\r\n            iplan: number;\r\n            constructor(n0: number, n1: number) {\r\n                this.n0 = n0;\r\n                this.n1 = n1;\r\n\r\n                this.size = n0 * n1;\r\n                this.c0ptr = fftwf_malloc(2 * 4 * this.size);\r\n                this.c1ptr = fftwf_malloc(2 * 4 * this.size);\r\n\r\n                this.c0 = new Float32Array(fftwModule.HEAPU8.buffer, this.c0ptr, 2 * this.size); // two for complex\r\n                this.c1 = new Float32Array(fftwModule.HEAPU8.buffer, this.c1ptr, 2 * this.size);\r\n\r\n                this.fplan = fftwf_plan_dft_2d(this.n0, this.n1, this.c0ptr, this.c1ptr, FFTW_FORWARD, FFTW_ESTIMATE);\r\n                this.iplan = fftwf_plan_dft_2d(this.n0, this.n1, this.c1ptr, this.c0ptr, FFTW_BACKWARD, FFTW_ESTIMATE);\r\n            }\r\n\r\n            forward(cpx: ArrayLike<number>) {\r\n                this.c0.set(cpx);\r\n                fftwf_execute(this.fplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.c1ptr, 2 * this.size);\r\n            }\r\n\r\n            inverse(cpx: ArrayLike<number>) {\r\n                this.c1.set(cpx);\r\n                fftwf_execute(this.iplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.c0ptr, 2 * this.size);\r\n            }\r\n\r\n            dispose() {\r\n                fftwf_destroy_plan(this.fplan);\r\n                fftwf_destroy_plan(this.iplan);\r\n                fftwf_free(this.c0ptr);\r\n                fftwf_free(this.c1ptr);\r\n            }\r\n        }\r\n\r\n        class C2CFFT1D implements FFT {\r\n            size: number;\r\n            c0ptr: number;\r\n            c1ptr: number;\r\n            c0: Float32Array;\r\n            c1: Float32Array;\r\n            fplan: number;\r\n            iplan: number;\r\n            constructor(size: number) {\r\n                this.size = size;\r\n                // this.c0ptr = fftwf_malloc(2*4*size + 2*4*size);\r\n                // this.c1ptr = this.c0ptr;\r\n                this.c0ptr = fftwf_malloc(2 * 4 * this.size);\r\n                this.c1ptr = fftwf_malloc(2 * 4 * this.size);\r\n\r\n                this.c0 = new Float32Array(fftwModule.HEAPU8.buffer, this.c0ptr, 2 * size);\r\n                this.c1 = new Float32Array(fftwModule.HEAPU8.buffer, this.c1ptr, 2 * size);\r\n\r\n                this.fplan = fftwf_plan_dft_1d(size, this.c0ptr, this.c1ptr, FFTW_FORWARD, FFTW_ESTIMATE);\r\n                this.iplan = fftwf_plan_dft_1d(size, this.c1ptr, this.c0ptr, FFTW_BACKWARD, FFTW_ESTIMATE);\r\n            }\r\n\r\n            forward(cpx: ArrayLike<number>) {\r\n                this.c0.set(cpx);\r\n                fftwf_execute(this.fplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.c1ptr, 2 * this.size);\r\n            }\r\n\r\n            inverse(cpx: ArrayLike<number>) {\r\n                this.c1.set(cpx);\r\n                fftwf_execute(this.iplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.c0ptr, 2 * this.size);\r\n            }\r\n\r\n            dispose() {\r\n                fftwf_destroy_plan(this.fplan);\r\n                fftwf_destroy_plan(this.iplan);\r\n                fftwf_free(this.c0ptr);\r\n                fftwf_free(this.c1ptr);\r\n            }\r\n        }\r\n\r\n        class R2CFFT1D implements FFT {\r\n            size: number;\r\n            rptr: number;\r\n            cptr: number;\r\n            r: Float32Array;\r\n            c: Float32Array;\r\n            fplan: number;\r\n            iplan: number;\r\n            constructor(size: number) {\r\n                this.size = size;\r\n                this.rptr = fftwf_malloc(size * 4 + (size + 2) * 4);\r\n                this.cptr = this.rptr + size * 4;\r\n\r\n                this.r = new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, size);\r\n                this.c = new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, size + 2);\r\n\r\n                this.fplan = fftwf_plan_dft_r2c_1d(size, this.rptr, this.cptr, FFTW_ESTIMATE);\r\n                this.iplan = fftwf_plan_dft_c2r_1d(size, this.cptr, this.rptr, FFTW_ESTIMATE);\r\n            }\r\n\r\n            forward(real: ArrayLike<number>) {\r\n                this.r.set(real);\r\n                fftwf_execute(this.fplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, this.size + 2);\r\n            }\r\n\r\n            inverse(cpx: ArrayLike<number>) {\r\n                this.c.set(cpx);\r\n                fftwf_execute(this.iplan);\r\n                return new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, this.size);\r\n            }\r\n\r\n            dispose() {\r\n                fftwf_destroy_plan(this.fplan);\r\n                fftwf_destroy_plan(this.iplan);\r\n                fftwf_free(this.rptr);\r\n            }\r\n        }\r\n\r\n        const r2r1dFactory = (forwardType: number, inverseType: number) => {\r\n            return class R2RFFT1D implements FFT {\r\n                size: number;\r\n                rptr: number;\r\n                cptr: number;\r\n                r: Float32Array;\r\n                c: Float32Array;\r\n                fplan: number;\r\n                iplan: number;\r\n                constructor(size: number) {\r\n                    this.size = size;\r\n                    this.rptr = fftwf_malloc(size * 4 + size * 4);\r\n\r\n                    this.cptr = this.rptr;\r\n                    this.r = new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, size);\r\n                    this.c = new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, size);\r\n\r\n                    this.fplan = fftwf_plan_r2r_1d(size, this.rptr, this.cptr, forwardType, FFTW_ESTIMATE);\r\n                    this.iplan = fftwf_plan_r2r_1d(size, this.cptr, this.rptr, inverseType, FFTW_ESTIMATE);\r\n                }\r\n\r\n                forward(real: ArrayLike<number>) {\r\n                    this.r.set(real);\r\n                    fftwf_execute(this.fplan);\r\n                    return new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, this.size);\r\n                }\r\n\r\n                inverse(cpx: ArrayLike<number>) {\r\n                    this.c.set(cpx);\r\n                    fftwf_execute(this.iplan);\r\n                    return new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, this.size);\r\n                }\r\n\r\n                dispose() {\r\n                    fftwf_destroy_plan(this.fplan);\r\n                    fftwf_destroy_plan(this.iplan);\r\n                    fftwf_free(this.rptr);\r\n                }\r\n            }\r\n        };\r\n\r\n        const r2r2dFactory = (forwardType: number, inverseType: number) => {\r\n            return class R2RFFT2D implements FFT {\r\n                n0: number;\r\n                n1: number;\r\n                size: number;\r\n                rptr: number;\r\n                cptr: number;\r\n                r: Float32Array;\r\n                c: Float32Array;\r\n                fplan: number;\r\n                iplan: number;\r\n                constructor(n0: number, n1: number) {\r\n                    this.n0 = n0;\r\n                    this.n1 = n1;\r\n\r\n                    this.size = this.n0 * this.n1;\r\n                    this.rptr = fftwf_malloc(this.size * 4);\r\n                    this.cptr = fftwf_malloc(this.size * 4);\r\n\r\n                    this.r = new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, this.size);\r\n                    this.c = new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, this.size);\r\n\r\n                    this.fplan = fftwf_plan_r2r_2d(this.n0, this.n1, this.rptr, this.cptr, forwardType, forwardType, FFTW_ESTIMATE);\r\n                    this.iplan = fftwf_plan_r2r_2d(this.n0, this.n1, this.cptr, this.rptr, inverseType, inverseType, FFTW_ESTIMATE);\r\n                }\r\n                \r\n                forward(real: ArrayLike<number>) {\r\n                    this.r.set(real);\r\n                    fftwf_execute(this.fplan);\r\n                    return new Float32Array(fftwModule.HEAPU8.buffer, this.cptr, this.size);\r\n                }\r\n\r\n                inverse(cpx: ArrayLike<number>) {\r\n                    this.c.set(cpx);\r\n                    fftwf_execute(this.iplan);\r\n                    return new Float32Array(fftwModule.HEAPU8.buffer, this.rptr, this.size);\r\n                }\r\n\r\n                dispose() {\r\n                    fftwf_destroy_plan(this.fplan);\r\n                    fftwf_destroy_plan(this.iplan);\r\n                    fftwf_free(this.rptr);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.c2c = {\r\n            FFT1D: C2CFFT1D,\r\n            FFT2D: C2CFFT2D\r\n        };\r\n        this.r2c = {\r\n            FFT1D: R2CFFT1D\r\n        };\r\n        this.r2r = {\r\n            FFT1D: r2r1dFactory(FFTW_R2HC, FFTW_HC2R),\r\n            DCT1D: r2r1dFactory(FFTW_REDFT10, FFTW_REDFT01),\r\n            DST1D: r2r1dFactory(FFTW_RODFT10, FFTW_RODFT01),\r\n            FFT2D: r2r2dFactory(FFTW_R2HC, FFTW_HC2R),\r\n            DCT2D: r2r2dFactory(FFTW_REDFT10, FFTW_REDFT01),\r\n            DST2D: r2r2dFactory(FFTW_RODFT10, FFTW_RODFT01)\r\n        }\r\n    }\r\n}\r\n\r\nexport default FFTW;\r\n"],
  "mappings": "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",
  "names": []
}
